\documentclass[a4paper, titlepage, french]{report}

\usepackage{amsmath,amsthm,amsfonts,delarray,fourier,manfnt}
\usepackage[utf8]{inputenc} % accents
\usepackage[T1]{fontenc}      % caractères français
\usepackage[french]{babel}  % langue
\usepackage{geometry,graphicx}         % marges % images
\usepackage{lmodern,eso-pic,fullpage}  
\usepackage{verbatim}         % texte préformaté
\usepackage{stackengine,scalerel}
\usepackage{authblk}
\usepackage[linesnumbered,algosection]{algorithm2e} %Pour le PDL
\usepackage{listings, xcolor}
\usepackage{moreverb,wasysym}
\usepackage{pgf, tikz} %pour dessiner
\usepackage{multicol} %pour avoir multiples colonnes localement
\usepackage{titlesec} %pour enlever le mot "chapitre"
\usepackage{lipsum} %ajouter du texte dans les dessins tikz
\usepackage{fancyvrb} %verbatim mais en mieux on l'utilise avec \begin{BVerbatim}, et cette fois on peut centrer
\usepackage{moreverb} %verbatim en box ebvironnement boxedverbatim
\usepackage{mdframed}

%\SetKwIF{Si}{SinonSi}{Sinon}{si}{alors}{sinon si}{alors}{finSi}



\usepackage[colorlinks=true, allcolors=black]{hyperref} %pour utiliser des liens internes, càd en réferencant une partie en peut mettre un lien vers celle-ci et ça avec \hyperref[nom du label]{le texte où y'aura le lien} sans oublier de mettre le \label{nom du label} sur la partie que vous voulez réferencer
\usepackage[bottom]{footmisc} %remettre le compteur de footnote à 0 par section.
\counterwithin*{footnote}{section} %numerote les footnote par section

                          % Le PDL
%les fonctions et leurs types

%pour les entiers
\SetKwProg{FnInt}{ \textcolor{blush}{entier} \textcolor{babyblueeyes}{fonction} }{}{\textcolor{babyblueeyes}{fin Fonction}}

%pour les caractères
\SetKwProg{FnChar}{ \textcolor{blush}{car} \textcolor{babyblueeyes}{fonction} }{}{\textcolor{babyblueeyes}{fin Fonction}}

%pour les booléens
\SetKwProg{FnBool}{ \textcolor{blush}{booléen} \textcolor{babyblueeyes}{fonction} }{ }{\textcolor{babyblueeyes}{fin Fonction}}

%pour les tableaux de dimension 1
\SetKwProg{FnTab}{\textcolor{blush}{tab[]} \textcolor{babyblueeyes}{fonction} }{}{\textcolor{babyblueeyes}{fin Fonction}}

%pour les tableaux de caractères
\SetKwProg{FnCharTab}{\textcolor{blush}{car[ ]} \textcolor{babyblueeyes}{fonction}  }{}{\textcolor{babyblueeyes}{fin Fonction}}

%pour les positions
\SetKwProg{FnPos}{ \textcolor{blush}{Position} \textcolor{babyblueeyes}{fonction} }{}{\textcolor{babyblueeyes}{fin Fonction}}

%pour les matrices de dimension 2
\SetKwProg{FnMat}{\textcolor{blush}{tab[][]} \textcolor{babyblueeyes}{fonction}}{}{\textcolor{babyblueeyes}{fin Fonction}}

%pour les réels
\SetKwProg{FnReel}{\textcolor{blush}{réel} \textcolor{babyblueeyes}{fonction} }{}{\textcolor{babyblueeyes}{fin Fonction}}

%Actions
\SetKwProg{Act}{\textcolor{chromeyellow}{action}}{}{\textcolor{chromeyellow}{fin Action}}

% \newmdenv[linewidth=0, leftmargin= -14,rightmargin= 14, backgroundcolor=red!10]{sourcecode}

%pour ajouter des commentaires dans l'algo 
%\tcp{. . .}

%couleur key words
\definecolor{babyblueeyes}{rgb}{0.63, 0.79, 0.95}%joli bleu
\definecolor{blush}{rgb}{0.87, 0.36, 0.51} %joli rose
\definecolor{chromeyellow}{rgb}{1.0, 0.65, 0.0} %joli jaune\orange pour julie 
\definecolor{camouflagegreen}{rgb}{0.47, 0.53, 0.42} %joli vert
\definecolor{cardinal}{rgb}{0.77, 0.12, 0.23} %joli rouge


\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\blap}[1]{\vbox to 0pt{#1\vss}}
\newcommand\AtUpperLeftCorner[3]{%
  \put(\LenToUnit{#1},\LenToUnit{\dimexpr\paperheight-#2}){\blap{#3}}%
}
\newcommand\AtTopCenterPage[2]{%
  \put(\LenToUnit{.5\paperwidth},\LenToUnit{\dimexpr\paperheight-#1}){\blap{\hbox to 0pt{\hss#2\hss}}}%
}

\newcommand\AtUpperRightCorner[3]{%
  \put(\LenToUnit{\dimexpr\paperwidth-#1},\LenToUnit{\dimexpr\paperheight-#2}){\blap{\llap{#3}}}%
}

\lstset{
  basicstyle=\ttfamily,
  mathescape=true
}

\definecolor{purple}{rgb}{0.57, 0.36, 0.51}

%algo
\RestyleAlgo{boxed}
 \SetAlgoSkip{1cm}
 
 



\title{\LARGE{Projet d'APOO} \\[0,5cm] \LARGE{Analyse du jeu de blocage avec polyominos}}
\author{   \\ Antoine \textsc{CUINET}  \\ Gaspar \textsc{QUENTIN}   }
\makeatletter


\begin{document}


\selectlanguage{french}
\begin{titlepage}
 \enlargethispage{3cm}
 
     \AddToShipoutPicture{
        \AtUpperLeftCorner{1.5cm}{1cm}{\includegraphics[width=6cm]{ufclogo.jpg}} 
    }

 \begin{center}	

        \vspace*{8cm}
 
        \textsc{\@title} \\
	\vspace*{0,5cm}
        \HRule
 	 \vspace*{0,5cm}
	\large{\@author} 
    \end{center}

  \vspace*{9cm}

   \end{titlepage}

\ClearShipoutPicture

%si on veut rajouter une page vide
%\newpage
%\thispagestyle{empty}
%\mbox{}
%\newpage

\tableofcontents
% \listofalgorithms

\newpage



















\chapter{Introduction}

Le projet est un projet de fin d'année de première année de licence informatique à l'université de Franche-Compté.

\bigskip

Ce rapport décrit et explique la conception de ce projet, qui est le jeu de blocage avec polyominos.

\bigskip

Le jeu est codé en Java et le joueur joue contre un ordinateur depuis le terminal.

\bigskip

Le but du jeu est relativement simple, chaque joueur dispose d'un ensemble de pièces, qui sont des polyominos, et qu'il place
tour à tour sur un plateau, qui est sous forme de grille rectangulaire. 

Il s'agit d'un jeu de blocage: le perdant est le premier
joueur qui ne peut plus placer de pièce.

Le jeu se déroule en mode
humain contre ordinateur: le joueur humain interagit via des affichages et des saisies sur la console.

\bigskip

Ce jeu à été coder par CUINET Antoine et QUENTIN Gaspard.



\newpage

\chapter{Les fonctionnalités}

Les fonctionnalités du jeu sont multiples.
\bigskip


Toutes fonctionnalités demandées dans le sujet ont été implantés.
\bigskip

Le joueur peu donc choisir son pseudo, choisir les pièces qu'il souhaites poser (Dominos, Triominos ou Tetrominos, elles ont toutes étés implantés) s'il lui en reste (des vérifications ont étés mises en places sur le nombre de pièce possible de choisir ainsi que sur la saisie qui doit être correcte).

Un affichage de chaque étapes du processus de choix d'une pièce est présenté au joueur ainsi que l'affichage de la pièce finalement choisi sur la grille (si elle ne sort pas de la grille et qu'elle ne chevauche aucune autre pièce, des vérifications demande au joueur de recommencer sa saisie si celle-ci est incorrecte).
\bigskip

Ensuite, l'ordinateur peu également jouer, il choisi et place ses pièces sur la grille de la même façon que le joueur.

Un affichage de la grille est présenté au joueur une fois que l'ordinateur à jouer avec un affichage de la pièce sur la grille ainsi qu'un message indiquant le type de pièce poser et la position de celle-ci.
\bigskip

Enfin, des fonctions ont été mises en place pour détecter la fin d'une partie. A ce moment, la partie s'arrête automatiquement et un message est afficher spécifiant le nom du gagnant.


\chapter{Les classe}

Le jeu dispose de 10 classes.
\bigskip

\section{La classe Main}

La classe Main est comme son nom l'indique la classe principale de notre projet.
Celle ci contient la méthode statique main qui s'occupe de créer les bons objets et
d'appeler les bonnes méthodes afin de créer une partie.
Cette classe contient également les méthodes permettant à l'utilisateur de jouer.

\bigskip

\section{La classe Computer}

La classe Computer s'occupe de faire jouer l'ordinateur contre le joueur. Les pièces placées
par l'ordinateur sont toutes choisies de manière aléatoire et placées de manière aléatoire également.

\bigskip

\section{La classe Piece}

La classe Pièce est une classe abstraite servant de modèles pour les classes Domino, Triomino et Tetromino
qui en hériteront.
Cette classe contient plusieurs méthodes virtuelles pures telles que getPositions() (qui renvoie un tableau de Position représentant
la pièce dans un espace orthonormé) ou encore la méthode toString() qui s'occupera d'afficher la pièce pour aider
l'utilisateur. Ces dernières seront donc entièrement redéfinies dans les classes enfant.

\bigskip

\section{La classe Grid}

La classe Grid représente la grille de jeu. Elle se charge également de l'affichage du plateau de jeu.
Elle est composée d'un tableau de 2 dimensions d'objets de type Case.
Elle comporte également les méthodes permettant au joueur et à l'ordinateur de voir si il est possible de
placer une pièce (méthode isPiecePlaceable()) et de la placer (méthode placePiece).

\bigskip

\section{La classe Position}

Cette classe est constituée de deux attributs : une positon en abscisse sur la grille et une position en 
ordonnée. Ces deux attributs sont des entiers. 
Elle possède également plusieurs méthodes utiles comme la méthode add() qui permet d'additionner deux 
positions entre elles.

\bigskip

\section{La classe Case}

Cette classe représente une case sur le plateau. Une case contient une pièce qui peut être nulle.
Elle possède également une redéfinition de la méthode toString() permettant d'afficher 
un rond si une pièce se trouve sur cette case et qu'elle appartient au joueur, un croisillon si une 
pièce se trouve sur cette case mais que cette pièce est une pièce ennemie et rien sinon.

\bigskip

\section{La classe Matrix}

Une pièce étant constituée de plusieurs objets Position, pour trouver l'orientation voulue pour placer
la pièce dans la grille, nous avons dû avoir recours à quelques petits calculs matriciels.
Cette classe sert donc principalement à calculer des coordonnées rotationnées à l'aide de cette
formule mathématique :

\[
    \begin{pmatrix}
        x' \\
        y'
    \end{pmatrix}
    \quad
    =
    \begin{pmatrix}
        \cos \psi & - \sin \psi \\
        \sin \psi & \cos \psi
    \end{pmatrix}
    \begin{pmatrix}
        x \\
        y
    \end{pmatrix}
\]


\bigskip

\section{La classe Domino}

La classe Domino, qui hérite de la classe Piece, se charge de créer des dominos avec le bon type 
en fonction du nombre d'instances déjà crées. Cette classe comporte une surchage de la métode toString()
permettant d'afficher toutes les différentes dispositions des dominos et de la méthode getPositions()
renvoyant toutes les positions représentant la pièce crée dans un repère orthonormé.

\bigskip

\section{La classe Triomino}

Cette classe fonctionne de façon identique à celle de la classe Domino.

\bigskip

\section{La classe Tetromino}

La classe Tetromino comporte la même logique d'implémentation que ces deux classes soeures, la classe Domino
et la classe Triomino.

\bigskip

\chapter{Initialisation de jeu}

Au début du jeu, un affichage permettant de saisir de pseudo du jeueur est mis à l'écran.

Une fois cette saisie faite, une explication du jeu, de l'ordinateur (qui se nome Yumi), ainsi que des pièces disponible est présenté.



\section{Dimensions du jeu}

Le plateau de jeu est un rectangle de 12 cases par 10 cases, qui sont numérotés en lettres (de A à L) en abscisse et en chiffre (de 0 à 9) en ordonné.

\section{Distribution des pièces}

Au début du jeu, le joueur comme l'ordinateur ont à disposition un même nombre de pièce.
\bigskip

Il est distribué 3 Dominos, 6 Triomino posable en 2 positions avec 3 pièces disponibles par position, et 9 Tétrominos posable en 7 positions avec 1 pièce disponible par position sauf pour les tétrominos de formes I et T qui sont aux nombre de 2.

Ainsi, chaque joueur un nobre de 60 cases sur un plateau faisant en tout 120 cases.

\chapter{Description des conditions}

Plusieur types de conditions sont utilisé afin de faire fonctionner au mieux le jeu.

\section{Placement des pièces}

\color{red}
// ici à faire
\color{black}


\section{La partie est finie}

\color{red}
// ici à faire
\color{black}


\chapter{Jeu de l'ordinateur}

Par manque de temps pour réaliser ce projet, notre ordinateur choisi ses pièce et les places aléatoirement.
\bigskip

Il place tout de même les pièce de façon coherente. C'est à dire qu'il place, tout comme le joueur, un nombre pré-définie de pièces d'un certain type et d'une certaine forme.

Autrement dit, l'ordinateur possède au début de la partie les mêmes pièce que le joueur et des vérifications sont faites afin q'il ne pose que les pièce dont il a le droit de poser et dans le nombre qu'il possède.
\chapter{Ajouts/libertés prises}

Afin de rajouter de la créativité, l'affichage de la grille est réalisé de façon originale. 
\bigskip

Le placement des pièces dans la grilles se fait en couleur, de façon à distinguer facilement celui que les a posées et afin de faire un affichage coloré (rouge pour l'ordinateur et bleu pour le joueur).
\bigskip

Le nom du jeueur ainsi que celui de l'ordinateur sont eux aussi en couleur (de même, rouge pour l'ordinateur et bleu pour le joueur).
\bigskip

Enfin, l'affichage des pièces en vert, qui est guidé tout au long du processus de choix d'une pièce, permet au joueur de facilement se rendre compte des pièces qu'il lui sont possible de poser.

 
\chapter{Conclusion}

Pour conclure ce rapport, nous avons produit un jeu amusant, autant dans la conception que dans son utilisation.
\bigskip

Certain problèmes ont été rencontrer comme celui de faire les tétrominons qui à été très long (autant dans la création des pièce que dans les affichages).
De plus, celui de distinguer les formes possibles de chaques pièces, en plus des différentes pièces et de leurs orientations.
\bigskip

Ces problèmes ont bien évidement trouver leurs solutions et nous ont permis de nous surpasser dans la création de ce jeu.
\bigskip

Concevoir ce jeu nous à également permis de mettre en pratique les cours appris tout au long de l'année et spécifiquement la programmation orienté objet.

\end{document}
